1. 为什么要有分布式锁
单机锁：sync、lock
多服务场景下，每个服务上都有一个单机锁，锁就不唯一了，所以需要分布式锁
2. 为什么不用MySQL来实现分布式锁
我们知道MySQL的for update可以上一个行锁，如
SELECT * FROM table WHERE id = 1 FOR UPDATE;
当多个线程同时执行这个语句时，只有一个线程能够成功获取锁。
问题是什么呢？容易死锁；本身MySQL数据库的压力就很大，成为性能瓶颈；
3. 常见方案之Redis
加锁：setnx key value，如果返回1，说明获取锁成功，如果返回0，说明获取锁失败；
解锁：del key

死锁问题：如果在加锁和解锁之间，服务器宕机了或者忘记del，那么就会出现死锁；
为了解决这个问题，我们可以给锁加一个过期时间，这样即便死锁了，过一段时间也会自动解锁；
expire key seconds

超时问题：如果你的业务逻辑执行时间超过了锁的过期时间，此时这个锁就已经失效了，其他线程可以获取到锁，但是你的业务逻辑还没有执行完，这样就会出现并发问题；
我们要想办法在业务逻辑执行完之前，不让锁失效，这样就使用一个守护线程去续锁。比如有一个定时任务，如果锁存在，就加一个过期时间，如果锁不存在，就不做任何操作；

原子性问题：解锁、加锁+设置TTL并不是原子操作
1）对于加锁+TTL，redis提供了一个拓展命令，可以在一次原子操作中完成加锁+设置TTL
如：SET key value nx ex 10 
2）对于解锁，在del之前一定要判断，只有锁持有者才能去解锁，不能让别人去解锁。
    我们可以对value做文章，存一个唯一标识。这个唯一标识只有锁持有者才知道，我们解锁前我们可以加一个这样的判断：
    if(get(key) == value) del(key)
    我们发现这里也是两个操作，而redis并没有为我们提供扩展命令
    那么我们就需要使用lua脚本了

可重入问题：线程持有者可以重复加锁